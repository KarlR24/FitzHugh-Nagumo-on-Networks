import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import seaborn as sns
from pathlib import Path
import os
from datetime import datetime
from moviepy.editor import *



def plot_activity(act_mat):
    """
    act_mat: list containing two 2Darrays
        output of the class FitzHugh_Nagumo_on_network
        Activity matrix [act_v, act_w] contains the time evolution of both variables of the FitzHugh-Nagumo model
    """
    _, ax = plt.subplots(figsize=(12, 4))
    ax.set_title('Activity of first variable', fontsize = 35)
    ax.plot(act_mat[0])
    ax.set_xlabel('Time', fontsize=25)
    ax.set_ylabel('v', fontsize=25)
    plt.xticks(fontsize = 22)
    plt.yticks(fontsize = 22)
    
    _, ax = plt.subplots(figsize=(12, 4))
    ax.set_title('Activity of first variable', fontsize = 35)
    ax.plot(act_mat[1])
    ax.set_xlabel('Time', fontsize=25)
    ax.set_ylabel('w', fontsize=25)
    plt.xticks(fontsize = 22)
    plt.yticks(fontsize = 22)
    return ax




def plot_phase_portrait(a, b, tau, act_mat, force_field=False):
    '''
    a, b, tau: parameters used in FitzHugh-Nagumo model
    
    act_mat: list containing two 2Darrays
        output of the class FitzHugh_Nagumo_on_network
        Activity matrix [act_v, act_w] contains the time evolution of both variables of the FitzHugh-Nagumo model

    force_field: optional
        draw arrows to show flow in phase plane
    '''
    if force_field is False:
        plt.figure(figsize=(20,20))
    
        # plot the nullclines
        x_null = np.arange(-5,5,.1) 
        y1 = [z-1./3*z**3 for z in x_null]
        y2 = [1/b*z+a/b for z in x_null]

        plt.plot(x_null,y1)
        plt.plot(x_null,y2)
    
        minv = act_mat[0].min() - 1
        maxv = act_mat[0].max() + 1
    
        minw = act_mat[1].min() - 1
        maxw = act_mat[1].max() + 1

        plt.xlim([minv, maxv])
        plt.ylim([minw, maxw])

        for i in range(int(len(adj_mat))):
            xs = act_mat[0]
            x = xs[:, i]       
            ys = act_mat[1]
            y = ys[:, i]
            plt.xlabel("v", fontsize=30)
            plt.ylabel("w", fontsize=30)
            plt.xticks(fontsize = 22)
            plt.yticks(fontsize = 22)
            plt.title('phase portrait', fontsize=35)
            plt.plot(x, y)
    
    else:
        plt.figure(figsize=(20,20))
        x, y = np.meshgrid(np.linspace(act_mat[0].min() - 1, act_mat[0].max() + 1, 25), np.linspace(act_mat[1].min() - 1, act_mat[1].max() + 1, 25))
        v = x-1./3*x**3 - y
        w = 1/tau * (x + a - b*y)
        plt.quiver(x, y, v, w)
    
        # plot the clines for v', w'
        x_null = np.arange(-5,5,.1) 
        y1 = [z-1./3*z**3 for z in x_null]
        y2 = [1/b*z+a/b for z in x_null]

        plt.plot(x_null,y1)
        plt.plot(x_null,y2)
    
        minv = act_mat[0].min() - 1
        maxv = act_mat[0].max() + 1
    
        minw = act_mat[1].min() - 1
        maxw = act_mat[1].max() + 1

        plt.xlim([minv, maxv])
        plt.ylim([minw, maxw])

        for i in range(int(len(adj_mat))):
            xs = act_mat[0]
            x = xs[:, i]       
            ys = act_mat[1]
            y = ys[:, i]
            plt.xlabel("v", fontsize=30)
            plt.ylabel("w", fontsize=30)
            plt.xticks(fontsize = 22)
            plt.yticks(fontsize = 22)
            plt.title('phase portrait', fontsize=35)
            plt.plot(x, y)







def runaround(act_mat, stepstart, stepend, stepsize):
    '''
    act_mat: nd array
        activity matrix from model
        
    stepstart: integer 
        starting time to begin taking pictures to make a GIF
        stepstart < T/delta_t, ie. total number of steps in model
        
    stepend: integer 
        time step where last pictures is taken for GIF
        stepstart < stepend < T/delta_t, ie. total number of steps in model   
    
    stepsize: integer
        every stepsize-number of timestep is taken from the activity matrix
    '''
    
    A = act_mat[0] 
    t_steps, N = A.shape
    
    minv = act_mat[0].min() - 1
    maxv = act_mat[0].max() + 1
    
    minw = act_mat[1].min() - 1
    maxw = act_mat[1].max() + 1
            
    for t in range(stepstart, stepend, stepsize):
            
        xs = act_mat[0]
        x = xs[t, :]       
        ys = act_mat[1]
        y = ys[t, :]
            
        fig = plt.figure(figsize=(10,10))
        sns.set_style("whitegrid")
        plt.scatter(x, y)
        
        # plot null-clines
        x_null = np.arange(minv,maxv,.1) 
        y1 = [z-1./3*z**3 for z in x_null]
        y2 = [1/0.1*z+0.3/0.1 for z in x_null]
        plt.plot(x_null,y1)
        plt.plot(x_null,y2)
        
        plt.xlim([minv, maxv])
        plt.ylim([minw, maxw])
        
        plt.title('t =%s' %t, fontsize=35)
        plt.xlabel("v", fontsize=30)
        plt.ylabel("w", fontsize=30)
        plt.xticks(fontsize = 22)
        plt.yticks(fontsize = 22)
        
        # save pngs to folder '/pngs' in the same directory
        # note: up to 9.999.999 time steps possible otherwise have to add line
        if t<100:
            plt.savefig('pngs/m_t0000%s.png' %round((t)))
        elif t<1000:
            plt.savefig('pngs/m_t000%s.png' %round((t)))
        elif t<10000:
            plt.savefig('pngs/m_t00%s.png' %round((t)))
        elif t<100000:
            plt.savefig('pngs/m_t0%s.png' %round((t)))
        else:
            plt.savefig('pngs/m_t%s.png' %round((t)))

        plt.clf()
        plt.cla()
        plt.close(fig)
        
        
        
        
def scatter_chim_gif(act_mat, start, stepsize):  
    '''
    act_mat: nd array
        activity matrix from model
        
    stepstart: integer 
        starting time to begin taking pictures to make a movie/GIF
        stepstart < T/delta_t = total number of steps in simulation
        
    stepsize: integer
        after stepsize many steps the next png is created
    '''
    
    A = act_mat[0] 
    t_steps, N = A.shape
    
    minv = act_mat[0].min() - 0.5
    maxv = act_mat[0].max() + 0.5
    
    for snapshot in range(start, t_steps, stepsize):   
        v_k = A[snapshot,:]   
        
        fig = plt.figure(figsize=(10,10))
        sns.set_style("whitegrid")
        plt.scatter(range(len(v_k)), v_k)
        plt.ylim([minv, maxv])  
        plt.xlabel("k", fontsize=30)
        plt.ylabel("$v_{k}(t)$", fontsize=30)
        plt.xticks(fontsize = 22)
        plt.yticks(fontsize = 22)
        plt.title('t =%s' %snapshot, fontsize=35)

        # note: up to 9.999.999 time steps possible otherwise have to add line
        if snapshot<100:
            plt.savefig('chimera/m_t0000%s.png' %round((snapshot)))
        elif snapshot<1000:
            plt.savefig('chimera/m_t000%s.png' %round((snapshot)))
        elif snapshot<10000:
            plt.savefig('chimera/m_t00%s.png' %round((snapshot)))
        elif snapshot<100000:
            plt.savefig('chimera/m_t0%s.png' %round((snapshot)))
        else:
            plt.savefig('chimera/m_t%s.png' %round((snapshot)))

        plt.clf()
        plt.cla()
        plt.close(fig)
        
        
        
        
def coh_gif(phase_coherence_v, simulation_run, stepsize):
    '''
    phase_coherence_v: 2d-array
        coherence measure values for every time step
        
    simulation_run: integer
        simulation run of interest to make video/GIF
    
    stepsize: integer
        after stepsize many steps the next png is created
    '''
    
    PCV_mat = phase_coherence_v[:,simulation_run]

    for t in range(0, len(PCV_mat), stepsize):   
        fig = plt.figure(figsize=(20,10))
        sns.set_style("whitegrid")
        plt.plot(PCV_mat)
        plt.axvline(x=t, color='r')
        plt.xlabel("Time t", fontsize=30)
        plt.ylabel("Phase Coherence", fontsize=30)
        plt.xticks(fontsize = 22)
        plt.yticks(fontsize = 22)
        step = start+t
        plt.title('t =%s' %step, fontsize=35)
        
        if t<100:
            plt.savefig('pngs/m_t0000%s.png' %round((t)))
        elif t<1000:
            plt.savefig('pngs/m_t000%s.png' %round((t)))
        elif t<10000:
            plt.savefig('pngs/m_t00%s.png' %round((t)))
        elif t<100000:
            plt.savefig('pngs/m_t0%s.png' %round((t)))
        else:
            plt.savefig('pngs/m_t%s.png' %round((t)))

        plt.clf()
        plt.cla()
        plt.close(fig)
        
        
        
def image_creator(G, act_mat, pos, colormap, stepstart, stepsize):
    '''
    G: network of interest
    
    act_mat: array
    
    pos: dictionary with nodes as keys and positions as values
    
    colormap: matplotlib.cm.colormap
        colormap for node states
        
    stepstart: float
        iteration step where first png is created
    
    stepsize: float
        after stepsize many iterations the next png is created
    '''
    
    A1 = act_mat[0] 
    t_steps, N = A1.shape

    minima = A1.min() #min value for colorscale
    maxima = A1.max() #max value for colorscale

    norm = matplotlib.colors.Normalize(vmin=minima, vmax=maxima, clip=True)
    mapper = matplotlib.cm.ScalarMappable(norm=norm, cmap=colormap)  #cividis

    # t_steps = int(1.*T/dt)
    for t in range(stepstart,t_steps,stepsize): 
        time_slice = A1[t,:]

        l_color = []

        for theta in time_slice:

            v = theta
            # print(v)
            red = int(255*mapper.to_rgba(v)[0])
            green = int(255*mapper.to_rgba(v)[1])
            blue = int(255*mapper.to_rgba(v)[2])
            hexcol = '#%02x%02x%02x' % (red, green, blue)
            # print(hexcol)
            l_color.append(hexcol)

        fig = plt.figure(figsize=(10,10))

        # posG = nx.circular_layout(graph_nx)
        nx.draw_networkx_nodes(G,pos=pos, node_color='k', node_size=80)
        nx.draw_networkx_nodes(G,pos=pos, node_color=l_color, node_size=40)
        nx.draw_networkx_edges(G,pos=pos,edge_color='#aaaaaa',alpha=.5)

        # a1 = nx.draw_networkx_nodes(G,pos = pos2d, node_c)
        plt.title('t =%s' %t, fontsize=35)
        plt.axis('off')
        
        if t<100:
            plt.savefig('pngs/m_t0000%s.png' %round((t)))
        elif t<1000:
            plt.savefig('pngs/m_t000%s.png' %round((t)))
        elif t<10000:
            plt.savefig('pngs/m_t00%s.png' %round((t)))
        elif t<100000:
            plt.savefig('pngs/m_t0%s.png' %round((t)))
        else:
            plt.savefig('pngs/m_t%s.png' %round((t)))

        plt.clf()
        plt.cla()
        plt.close(fig)
    
    
    
    
def GIF_creator(duration, png_dir, path):
    '''
    duration: float
        time each picture is shown in GIF
        
    png_dir: string
        direction where .pngs are to make GIF out of
    
    path: string
        direction where the GIF should be saved
        
    this code is from stackoverflow.com
    '''

    time_now = datetime.today().strftime("%d-%m-%Y %H%M%S")
    images = []
    for file_name in sorted(os.listdir(png_dir)):
        if file_name.endswith('.png'):
            file_path = os.path.join(png_dir, file_name)
            images.append(imageio.imread(file_path))
    #imageio.mimsave(FHNgif.gif, path, images, format='GIF')
    imageio.mimsave(os.path.join('my_very_own_gif_%s.gif' %time_now), images, duration = duration)
    
    
    
    
    
def video_maker(duration, image_dir):
    '''
    duration: float
        how long one png is shown in seconds
        
    image_dir: string
        path to where pngs should be taken from
        the images are used in alphanumeric order

    This code was refined by [unfriend](https://github.com/unfriend)
    '''
    # Create a list of file names for all PNG images in the directory
    image_files = [os.path.join(image_dir, f) for f in sorted(os.listdir(image_dir)) if f.endswith('.png')]

    # Define the name and location of your output video file
    time_now = datetime.today().strftime("%d-%m-%Y %H%M%S")
    video_path = './phase_coherence_%s.mp4'%time_now

    # Define the frames per second and the codec for the video
    fps = int(1/duration)
    codec = 'h264'

    # Use imageio to create the video from the list of image files
    with imageio.get_writer(video_path, fps=fps, codec=codec) as writer:
        for filename in image_files:
            image = imageio.imread(filename)
            writer.append_data(image)
